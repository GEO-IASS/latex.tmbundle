import sys
import re
import os.path
import os

from re import compile
from os import getcwd
from os.path import join
from sys import stdout
from urllib import quote


def make_link(file, line=1):
    """Create a TextMate link for ``file`` pointing to ``line``.

    Arguments:

        file

            The path to the file that should be opened if we click the link
            generated by this function.

        line

            The line which should be displayed when TextMate opens ``file``.

    Returns: ``str``

    Examples:

        >>> make_link('Tests/TeX/makeindex.tex', 1)
        'txmt://open/?url=file://Tests/TeX/makeindex.tex&line=1'
        >>> make_link('Wide Open Spaces.txt', 20)
        'txmt://open/?url=file://Wide%20Open%20Spaces.txt&line=20'

    """
    return "txmt://open/?url=file://{}&line={}".format(quote(file), line)


class TexParser(object):
    """Parse TeX typesetting streams.

    This class reads output from a tex program and tries to convert this
    information into HTML.

    """

    def __init__(self, input_stream, verbose):
        """Initialize a new TexParser.

        Arguments:

            input_stream

                A stream like object containing data produced by a tex program.

            verbose

                Specifies if the output produced by this class should cover
                all messages provided by input stream (verbose=True) or if
                only messages about important events should produce output by
                this class.

        Examples:

            >>> with open('Tests/Log/external_bibliography.log') as log:
            ...     parser = TexParser(log, True)

        """
        self.input_stream = input_stream
        self.patterns = []
        self.done = False
        self.verbose = verbose
        self.number_errors = 0
        self.number_warnings = 0
        self.fatal_error = False

    def get_rewrapped_line(self):
        """Try to get exactly one line of coherent tex output.

        Sometimes TeX breaks up lines with hard line breaks. This is
        annoying. Even more annoying is that it sometime does not break line,
        for two distinct warnings. This function attempts to return a single
        statement.

        Returns: ``str``

        Examples:

            >>> with open('Tests/Log/latexmk.log') as log: # doctest:+ELLIPSIS
            ...     parser = TexParser(log, True)
            ...     line = parser.get_rewrapped_line()
            ...     while line:
            ...         print(line)
            ...         line = parser.get_rewrapped_line()
            Latexmk: ...
            ...
            \EU1/AvenirNext(0)/m/n/... on all fair paths ...
            ...

        """
        statement = ""
        while True:
            line = self.input_stream.readline()
            if not line:
                return statement
            statement += line.rstrip('\n')
            if not (len(line) == 80 and not line[78] in {'!', '.'}):
                break
        return statement + '\n'

    def parse_stream(self):
        """Process the input stream one line at a time.

        We match against each pattern in the patterns dictionary. If a pattern
        matches we call the corresponding method in the dictionary. The
        dictionary is organized with patterns as the keys and methods as the
        values.

        This method returns a tuple containing the following values:

            - A boolean value specifying if there was a fatal error
              encountered by the tex program.

            - The number of errors found in the stream

            - The number of warnings found in the stream

        Returns: ``(bool, int, int)``

        Examples:

            >>> status = None
            >>> # Since the pattern dictionary of ``TexParser`` is empty the
            >>> # following will print nothing
            >>> with open('Tests/Log/external_bibliography.log') as log:
            ...     parser = TexParser(log, False)
            ...     status = parser.parse_stream()
            >>> status
            (False, 0, 0)

        """
        line = self.get_rewrapped_line()
        while line and not self.done:
            line = line.rstrip("\n")
            found_match = False

            # Process matching patterns until we find one
            for patttern, function in self.patterns:
                match = patttern.match(line)
                if match:
                    function(match, line)
                    stdout.flush()
                    found_match = True
                    break
            if self.verbose and not found_match:
                print(line)

            line = self.get_rewrapped_line()
        if not self.done:
            self.bad_run()
        return self.fatal_error, self.number_errors, self.number_warnings

    def info(self, match, line):
        """Print a message containing ``line``.

        The functions of the form ``function(self, match, line)`` in this
        class and all subclasses use the same interface. We will therefore
        describe their behaviour only here once.

        Arguments:

            match

                A regex match containing the match for the given line. What the
                match contains is dependent on the regex, which lead to the
                call of this function.

            line

                A string containing the regex pattern which lead to the call
                of this function

        Returns: ``str``

        """
        print('<p class="info">{}</p>'.format(line))

    def error(self, match, line):
        print('<p class="error">{}</p>'.format(line))
        self.number_errors += 1

    def warning(self, match, line):
        print('<p class="warning">{}</p>'.format(line))
        self.number_warnings += 1

    def warning_format(self, match, line):
        print('<p class="fmtWarning">{}</p>'.format(line))

    def fatal(self, match, line):
        print('<p class="error">{}</p>'.format(line))
        self.fatal_error = True

    def bad_run(self):
        pass


class BibTexParser(TexParser):
    """Parse and format messages from bibtex"""

    def __init__(self, input_stream, verbose):
        """Initialize the regex patterns for the BibTexParser"""
        super(BibTexParser, self).__init__(input_stream, verbose)
        self.patterns.extend([
            (compile("Warning--"), self.warning),
            (compile(r'I found no \\\w+ command'), self.error),
            (compile("I couldn't open style file"), self.error),
            (compile(r"You're missing a field name---line (\d+)"), self.error),
            (compile(r'Too many commas in name \d+ of'), self.error),
            (compile('I was expecting a'), self.error),
            (compile('This is BibTeX'), self.info),
            (compile('The style'), self.info),
            (compile('Database'), self.info),
            (compile(r'(---)|(\(There were .*\))'), self.finish_run)
        ])

    def parse_stream(self):
        r"""Parse log messages from bibtex.

        Examples:

            >>> status = None
            >>> with open('Tests/Log/bibtex.log') as log:  # doctest:+ELLIPSIS
            ...     parser = BibTexParser(log, False)
            ...     status = parser.parse_stream()
            <p class="info">This is BibTeX...</p>
            <p class="info">The style file: alpha.bst</p>
            <p class="info">Database file #1: References.bib</p>
            <p class="warning">Warning--entry...isn't style-file defined</p>
            <p class="warning">Warning--empty journal in Rea...</p>
            <p class="warning">Warning--I didn't find ... "Haggarty:01"</p>
            <p class="warning">Warning--to sort,... in IEEE_1003_26</p>
            <p class="warning">... "Realtime_Linux_Academic_Vs_Reality"...</p>
            <p class="error">I was expecting ... biblio.bib</p>
            <p class="error">Too many commas...for entry Arridge89</p>
            <p class="error">You're missing...---line 5 of file biblio.bib</p>
            <p class="error">I found no \bibdata command---while ...2a.aux</p>
            <p class="error">I couldn't open style file natbib.bst</p>
            >>> status
            (False, 5, 5)
            >>> parser.done
            True

        """
        return super(BibTexParser, self).parse_stream()

    def finish_run(self, match, line):
        self.done = True


class BiberParser(TexParser):
    """Parse and format messages from biber"""

    def __init__(self, input_stream, verbose):
        """Initialize the regex patterns for the BiberParser"""
        super(BiberParser, self).__init__(input_stream, verbose)
        self.patterns.extend([
            (compile('INFO - This is Biber'), self.info),
            (compile('WARN'), self.warning),
            (compile('ERROR'), self.error),
            (compile('FATAL'), self.fatal),
            (compile('^.*Output to (.*)$'), self.finish_run),
        ])

    def parse_stream(self):
        """Parse log messages from biber.

        Examples:

            >>> status = None
            >>> with open('Tests/Log/biber.log') as log:  # doctest:+ELLIPSIS
            ...     parser = BiberParser(log, False)
            ...     status = parser.parse_stream()
            <p class="info">INFO - This is Biber...</p>
            <p class="warning">WARN - Warning: Found ... expected... 2.5</p>
            <p class="error">FATAL - Cannot find ... to BibLaTeX?</p>
            <p class="error">ERROR - Cannot find file '.../References1'!</p>
            <p>Complete transcript is in ...</a></p>
            >>> status
            (True, 1, 1)
            >>> parser.done
            True

        """
        return super(BiberParser, self).parse_stream()

    def finish_run(self, match, line):
        log = match.group(1)
        print('<p>Complete transcript is in <a href="{}">{}</a></p>'.format(
              make_link(join(getcwd(), log)), log))
        self.done = True


class MakeGlossariesParser(TexParser):
    """Parse and format messages from makeglossaries."""

    def __init__(self, input_stream, verbose):
        """Initialize the regex patterns for the MakeGlossariesParser"""
        super(MakeGlossariesParser, self).__init__(input_stream, verbose)
        self.patterns.extend([
            (compile('^.*makeglossaries version (.*)$'), self.begin_run),
            (compile('^.*added glossary type \'(.*)\' \((.*)\).*$'),
             self.add_type),
            (compile(r'This is makeindex, version (\d+\.\d+)'),
             self.run_makeindex),
            (compile(r'(\w+ \w+ file) (?:\./)?' +
                     r'(.*\.(?:(?:acr)|(?:ist)|(?:glo)|(?:gls))).*\((.*)\)'),
             self.work_with_file),
            (compile(r'(\w+ written in) (.*)\.$'), self.written),
            (compile(r'Sorting entries.*\((.*)\)'), self.sorting),
            (compile('^.*Markup written into file "(.*)".$'),
             self.finish_markup),
            (compile('^.*xindy.*-L (.*) -I.*-t ".*\.(.*)" -o.*$'),
             self.run_xindy),
            (compile('Cannot locate xindy module'), self.warning),
            (compile('ERROR'), self.error),
            (compile('Warning'), self.warning),
            (compile('^\*\*\*'), self.info),
        ])
        self.types = {}

    def parse_stream(self):
        """Parse log messages from makeglossaries.

        Examples:

            >>> status = None
            >>> filepath = 'Tests/Log/makeglossaries.log'
            >>> with open(filepath) as log:  # doctest:+ELLIPSIS
            ...     parser = MakeGlossariesParser(log, False)
            ...     status = parser.parse_stream()
            <h2>Make Glossaries</h2><p class="info" >Version: <i>...</i></p>
            <p class="info">Add...main... (Files: glg,gls,glo)</i></p>
            ...
            <p class="info">Run <strong>Makeindex</strong>, version ...<p>
            <p class="info">Scanning...makeglossaries.ist:...29 a...0 i...
            ...
            <p class="info">Sorting entries: <strong>0 comparisons</strong><p>
            ...Generating...makeglossaries.gls:...6 lines written, 0...
            ...Out... <a href="txmt://open/?url=file://.../...gls&line=1">...
            ...
            <h3>Run xindy for glossary type main...Language: english...
            ...Finished ...main...Out...in <a ...makeglossaries.gls...</p>
            >>> status
            (False, 0, 0)

        """
        return super(MakeGlossariesParser, self).parse_stream()

    def begin_run(self, match, line):
        version = match.group(1)
        print('<h2>Make Glossaries</h2>' +
              '<p class="info" >Version: <i>{}</i></p>'''.format(version))

    def add_type(self, match, line):
        glossary_type = match.group(1)
        files = match.group(2)
        for file in files.split(','):
            self.types[file] = glossary_type
        print('<p class="info">Add Glossary Type <strong>' +
              '{}</strong><i> (Files: {})</i></p>'.format(glossary_type,
                                                          files))

    def run_makeindex(self, match, line):
        version = match.group(1)
        print('<p class="info">Run <strong>Makeindex</strong>, ' +
              'version {}<p>'.format(version))

    def run_xindy(self, match, line):
        language = match.group(1)
        file = match.group(2)
        glossary_type = self.types[file]
        print('<h3>Run xindy for glossary type {}</h3>'.format(glossary_type) +
              '<p class="info">Language: {}</p>'.format(language))

    def sorting(self, match, line):
        status = match.group(1)
        print('<p class="info">Sorting entries: <strong>' +
              '{}</strong><p>'.format(status))

    def written(self, match, line):
        description = match.group(1)
        filename = match.group(2)
        filepath = make_link(join(getcwd(), filename))
        print('<p class="info">{} <a href="{}">{}</a></p>'.format(
              description, filepath, filename))

    def work_with_file(self, match, line):
        description = match.group(1)
        filename = match.group(2)
        status = match.group(3)
        print('<p class="info">{} {}: <strong>{}</strong>'.format(description,
              filename, status))

    def finish_markup(self, m, line):
        mkfile = m.group(1)
        glossary_type = self.types[mkfile[-3:]]
        print('<p class="info">Finished glossary for type <strong>' +
              '{}</strong>. Output is in <a href="{}">{}</a></p>'.format(
              glossary_type, make_link(join(getcwd(), mkfile), 1), mkfile))


class LaTexParser(TexParser):
    """Parse Output From Latex"""

    def __init__(self, input_stream, verbose, fileName):
        super(LaTexParser, self).__init__(input_stream, verbose)
        self.suffix = fileName[fileName.rfind('.')+1:]
        self.currentFile = fileName
        self.patterns += [
            #(re.compile('^This is') , self.info),
            (re.compile('^Document Class'), self.info),
            (re.compile('.*?\((\.\/[^\)]*?\.(tex|'+self.suffix+')( |$))'),
             self.detectNewFile),
            (re.compile('.*\<use (.*?)\>'), self.detectInclude),
            (re.compile('^Output written'), self.info),
            (re.compile('LaTeX Warning:.*?input line (\d+)(\.|$)'),
             self.handleWarning),
            (re.compile('LaTeX Warning:.*'), self.warning),
            (re.compile('^([^:]*):(\d+):\s+(pdfTeX warning.*)'),
             self.handleFileLineWarning),
            (re.compile('.*pdfTeX warning.*'), self.warning),
            (re.compile('LaTeX Font Warning:.*'), self.warning),
            (re.compile('Overfull.*wide'), self.warning_format),
            (re.compile('Underfull.*badness'), self.warning_format),
            (re.compile('^([\.\/\w\x7f-\xff\- ]+(?:\.sty|\.tex|\.' +
                        self.suffix+')):(\d+):\s+(.*)'),
             self.handleError),
            (re.compile('([^:]*):(\d+): LaTeX Error:(.*)'), self.handleError),
            (re.compile('([^:]*):(\d+): (Emergency stop)'), self.handleError),
            (re.compile('Runaway argument'), self.pdfLatexError),
            # We need the (.*) at the beginning of the regular expression
            # since in some edge cases cases the output about the transcript
            # might actually not start at the beginning of the line.
            (re.compile('(.*)Transcript written on (.*)\.$'), self.finishRun),
            (re.compile('^Error: pdflatex'), self.pdfLatexError),
            (re.compile('\!.*'), self.handleOldStyleErrors),
            (re.compile('^\s+==>'), self.fatal)
        ]
        self.blankLine = re.compile(r'^\s*$')

    def detectNewFile(self, m, line):
        self.currentFile = m.group(1).rstrip()
        print "<h4>Processing: " + self.currentFile + "</h4>"

    def detectInclude(self, m, line):
        print "<ul><li>Including: " + m.group(1)
        print "</li></ul>"

    def handleWarning(self, m, line):
        print('<p class="warning"><a href="' +
              make_link(os.path.join(os.getcwd(), self.currentFile),
                        m.group(1)) + '">' + line + "</a></p>")
        self.number_warnings += 1

    def handleFileLineWarning(self, m, line):
        """Display warning. match m should contain file, line, warning
        message"""
        print('<p class="warning"><a href="' +
              make_link(os.path.join(os.getcwd(), m.group(1)), m.group(2)) +
              '">' + m.group(3) + "</a></p>")
        self.number_warnings += 1

    def handleError(self, m, line):
        print '<p class="error">'
        print('Latex Error: <a  href="' +
              make_link(os.path.join(os.getcwd(), m.group(1)), m.group(2)) +
              '">' + m.group(1) + ":" + m.group(2) + '</a> '+m.group(3)+'</p>')
        self.number_errors += 1

    def finishRun(self, m, line):
        logFile = m.group(2).strip('"')
        print '<p>  Complete transcript is in '
        print('<a href="' +
              make_link(os.path.join(os.getcwd(), logFile), '1') + '">' +
              logFile + '</a>')
        print '</p>'
        self.done = True

    def handleOldStyleErrors(self, m, line):
        if re.search('[Ee]rror', line):
            print '<p class="error">'
            print line
            print '</p>'
            self.number_errors += 1
        else:
            print '<p class="warning">'
            print line
            print '</p>'
            self.number_warnings += 1

    def pdfLatexError(self, m, line):
        """docstring for pdfLatexError"""
        self.number_errors += 1
        print '<p class="error">'
        print line
        line = self.input_stream.readline()
        if line and re.match('^ ==> Fatal error occurred', line):
            print line.rstrip("\n")
            print '</p>'
            self.fatal_error = True
        else:
            if line:
                print '<pre>    ' + line.rstrip("\n") + '</pre>'
            print '</p>'
        sys.stdout.flush()

    def bad_run(self):
        """docstring for finishRun"""
        print '<p class="error">A fatal error occurred, log file is in '
        logFile = os.path.basename(os.getenv('TM_FILEPATH'))
        logFile = logFile.replace(self.suffix, 'log')
        print('<a href="' +
              make_link(os.path.join(os.getcwd(), logFile), '1') + '">' +
              logFile + '</a>')
        print '</p>'


class ParseLatexMk(TexParser):
    """docstring for ParseLatexMk"""

    def __init__(self, input_stream, verbose, filename):
        super(ParseLatexMk, self).__init__(input_stream, verbose)
        self.fileName = filename
        self.patterns += [
            (re.compile('This is (pdfTeX|latex2e|latex|XeTeX)'),
             self.startLatex),
            (re.compile('This is BibTeX'), self.startBibtex),
            (re.compile('^.*This is biber'), self.startBiber),
            (re.compile('^Latexmk: All targets \(.*?\) are up-to-date'),
             self.finishRun),
            (re.compile('This is makeindex'), self.startBibtex),
            (re.compile('^Latexmk'), self.ltxmk),
            (re.compile('Run number'), self.newRun)
        ]
        self.numRuns = 0

    def startBibtex(self, m, line):
        print '<div class="bibtex">'
        print '<h3>' + line[:-1] + '</h3>'
        bp = BibTexParser(self.input_stream, self.verbose)
        f, e, w = bp.parse_stream()
        self.number_errors += e
        self.number_warnings += w

    def startBiber(self, m, line):
        print '<div class="biber">'
        print '<h3>' + line + '</h3>'
        bp = BiberParser(self.input_stream, self.verbose)
        f, e, w = bp.parse_stream()
        self.number_errors += e
        self.number_warnings += w

    def startLatex(self, m, line):
        print '<div class="latex">'
        print '<hr>'
        print '<h3>' + line[:-1] + '</h3>'
        bp = LaTexParser(self.input_stream, self.verbose, self.fileName)
        f, e, w = bp.parse_stream()
        self.number_errors += e
        self.number_warnings += w

    def newRun(self, m, line):
        if self.numRuns > 0:
            print '<hr />'
            print("<p> {} Errors {} Warnings in this run.</p>".format(
                  self.number_errors, self.number_warnings))
        self.number_warnings = 0
        self.number_errors = 0
        self.numRuns += 1

    def finishRun(self, m, line):
        self.ltxmk(m, line)
        self.done = True

    def ltxmk(self, m, line):
        print '<p class="ltxmk">%s</p>' % line


class ChkTeXParser(TexParser):
    """Parse the output from chktex"""
    def __init__(self, input_stream, verbose, filename):
        super(ChkTeXParser, self).__init__(input_stream, verbose)
        self.fileName = filename
        self.patterns += [
            (re.compile('^ChkTeX'), self.info),
            (re.compile('Warning \d+ in (.*.tex) line (\d+):(.*)'),
             self.handleWarning),
            (re.compile('Error \d+ in (.*.tex) line (\d+):(.*)'),
             self.handleError),
        ]
        self.numRuns = 0

    def handleWarning(self, m, line):
        """Display warning. match m should contain file, line, warning
        message"""
        print('<p class="warning">Warning: <a href="' +
              make_link(os.path.join(os.getcwd(), m.group(1)), m.group(2)) +
              '">' + m.group(1) + ": " + m.group(2) + ":</a>" + m.group(3) +
              "</p>")
        warnDetail = self.input_stream.readline()
        if len(warnDetail) > 2:
            print '<pre>', warnDetail[:-1]
            print self.input_stream.readline()[:-1], '</pre>'
        self.number_warnings += 1

    def handleError(self, m, line):
        print '<p class="error">'
        print('Error: <a  href="' +
              make_link(os.path.join(os.getcwd(), m.group(1)), m.group(2)) +
              '">' + m.group(1) + ":" + m.group(2) + ':</a> ' + m.group(3) +
              '</p>')
        print '<pre>', self.input_stream.readline()[:-1]
        print self.input_stream.readline()[:-1], '</pre>'
        self.number_errors += 1

if __name__ == '__main__':
    # test
    stream = open('../tex/test.log')
    lp = LaTexParser(stream, False, "test.tex")
    lp = BiberParser(stream, False)
    f, e, w = lp.parseStream()
